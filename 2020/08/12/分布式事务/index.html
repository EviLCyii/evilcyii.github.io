<!DOCTYPE html><html lang="zh-CN" data-default-color-scheme="&#34;auto&#34;"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/image/cy.png"><link rel="icon" type="image/png" href="/image/cy.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="#1a202c"><meta name="description" content="Cyii博客"><meta name="author" content="云"><meta name="keywords" content="博客"><title>分布式事务解决方案 - Cyii</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="/lib/hint/hint.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/github-gist.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_6peoq002giu.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_2025161_ae63sf8bwnr.css"><script src="/js/utils.js"></script><script src="/js/color-schema.js"></script><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:60vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>Cyii</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;<i class="iconfont icon-search"></i>&nbsp;</a></li><li class="nav-item" id="color-toggle-btn"><a class="nav-link" href="javascript:">&nbsp;<i class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a></li></ul></div></div></nav><div class="banner intro-2" id="background" parallax="true" style="background:url(/image/banner/dark-fish.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container page-header text-center fade-in-up"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-08-12 15:10" pubdate>2020年8月12日 下午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 4k 字</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><article class="post-content mx-auto" id="post"><h1 style="display:none">分布式事务解决方案</h1><div class="markdown-body" id="post-body"><h2 id="什么是事务">什么是事务</h2><p>事务是执行操作的一个逻辑单位。只有在所有操作都成功的前提下，事务才算完成。否则，只要其中有任一操作失败，则整个事务失败，将退回至事务开始前的状态，像是什么也没发生。这就是事务的<code>原子性（Atomicity）</code>。除了原子性，事务还有<code>一致性（Consistency）</code>、<code>隔离性（Isolation）</code>、<code>持久性（Durability）</code>，共四个特性。简称事务的ACID特性。</p><h3 id="ACID特性">ACID特性</h3><ul><li><p><code>A 原子性</code></p><p>就如上面所说，事务执行操作要么都成功有效，要么都失败。<strong>事务中的操作不可分割。</strong></p></li><li><p><code>C 一致性</code></p><p>数据只可能是事务之前的状态或事务完成之后的状态。它不会是事务完成一半的中间状态。</p></li><li><p><code>I 隔离性</code></p><p>各个事务之间的数据状态相互隔离。比如一个事务T1有两个操作，将A变成B和将1变成2。另一个事务在查询数据的时候只可能看到T1执行成功前的状态（A、1）或者执行成功后的状态（B、2），不可能是中间状态比如（B、1)。</p></li><li><p><code>D 持久性</code></p><p>已被提交的事务如果执行成功，那么结果将永久的保留、有效。即使出现系统宕机重启，也不会影响已经完成的事务。</p></li></ul><h2 id="分布式事务概念">分布式事务概念</h2><h3 id="什么是分布式事务">什么是分布式事务</h3><p>分布式事务，顾名思义，就是在分布式系统中的事务，且事务的操作内容在不同的节点上执行。<strong>分布式事务就是为了尽可能地保证分布式中地数据一致性。</strong></p><h3 id="分布式事务与传统事务的不同">分布式事务与传统事务的不同</h3><p>传统事务的数据操作是在单一节点、单一数据库中完成的，事务中的操作一气呵成。而分布式事务的操作是在不同节点中完成，对不同节点的操作请求、以及访问各个节点的操作结果是需要通过网络传输的。 <strong>而网络传输是难免会有不稳定以及无法保证实效，从而ACID中的数据一致性很难保证。</strong> 比如某一个操作执行完成了，通知其他节点的时候网络不稳定没通知上，那么其他节点可能会认为这个操作失败了，导致其他节点数据回滚，从而各个节点数据不一致。 <strong>这就是分布式事务要解决的问题。</strong></p><h3 id="CAP原则">CAP原则</h3><p>在分布式系统中，永远绕不开CAP原则。</p><ul><li><p><code>Consistency（一致性）</code></p><p>各个节点中的数据在同一时刻能读到的数据是一致的、最新写入的。这与<a href="#ACID%E7%89%B9%E6%80%A7">ACID特性</a>的一致性概念完全不同。</p></li><li><p><code>Availability（可用性）</code></p><p>即使有部分节点不可用（比如宕机），其他可用的节点依旧能访问，整个系统依旧是保持可用的。</p></li><li><p><code>Partition tolerance（分区容错性）</code></p><p>例：有两个节点A、B，如果B节点的网络出了问题无法跟A正常通信了，那么它们俩就发生了分区。分区容错性就是指发生分区时，整个系统仍可用。</p></li></ul><p><strong>CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP。</strong></p><p>例如如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时 C 和 P 两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了 CP 系统。<ins>Zookeeper就是典型的CP系统。</ins></p><h3 id="BASE原则">BASE原则</h3><p>那么既然CAP不能三者共存，意味着一个分布式系统在CAP中必须要有所取舍。我们这里就用常规的业务系统来作例子。</p><p>在大多数业务系统，可用性是需要保证的。大型的生产环境中每个服务往往会有多个实例以此来保证系统的高可用，如果其中一个实例挂了其他实例就都用不了，那显然就不是高可用了。<strong>所以可用性是必要的。</strong> 同时，如果一个系统中的某一服务暂时不可达，这个系统就不能用的话这也会有问题的。比如说系统的非核心服务挂了，如统计服务，它就完全不可用了，用户也登录不了，那显然也是不行的。<strong>所以分区容错性也是需要保证的。</strong></p><p><strong>因此在大多数业务系统中，优先保证AP是比较常见的。当然不同的系统要根据自身的需求来决定到底如何取舍。</strong></p><p>既然我们选择了AP，那数据的实时强一致性就没有办法保证了。但是我们也不能让数据总是不一致，总需要有个办法让数据即使不是实时的，但经过一段时间最终还是要能保持一致。所以，就有了<strong>BASE原则。</strong></p><p>BASE ，是<strong>B</strong>asically <strong>A</strong>vailable, <strong>S</strong>oft state, <strong>E</strong>ventual consistency 的首字母简写。它是CAP中AP的一种衍生。</p><ul><li><p><code>BA: 基本可用</code></p><p>即使系统出现某些问题，基本的读写操作要尽可能地可用。</p></li><li><p><code>S: 软状态</code></p><p>允许系统存在数据暂时不一致的软状态。（这里就是无法保证CAP中的一致性）</p></li><li><p><code>E: 最终一致性</code></p><p>如果系统运行正常，那么在运行一段时间后，各个节点的数据会最终达成一致。</p></li></ul><p>BASE中的<code>软状态</code>和<code>最终一致性</code>就达到了上面我们想要的效果：<strong>经过一段时间延迟后数据最终还是要能保持一致。</strong></p><h3 id="分布式事务的缺点">分布式事务的缺点</h3><p>以上我们了解到，分布式事务是很难达到强一致性的，<strong>那么在对数据一致性要求高、数据间依赖关系强的地方是不适合的，这种情况最好设计成单机本地事务。同时，分布式事务也极大增加了系统的复杂性和耦合度。</strong> 这也对开发人员带来了不少挑战与麻烦。系统的设计、维护成本也会大大提高。</p><h2 id="分布式事务解决方案">分布式事务解决方案</h2><h3 id="二阶段提交协议">二阶段提交协议</h3><p>二阶段提交（Two-phase Commit protocol），简称2PC，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议。</p><p>二阶段提交算法的成立基于以下假设：</p><ol><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Participants)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ol><p>二阶段提交，顾名思义，就是将分布式事务分成两个阶段：</p><h4 id="第一阶段：准备阶段">第一阶段：准备阶段</h4><p>准备阶段就是协调者询问每个参与者是否准备好各自的事务：协调者向参与者发起准备命令，那么参与者就开始创建事务，并执行事务但不提交(<code>commit</code>)。之后每个参与者返回自己的状态：<code>执行成功</code> 或者 <code>执行失败</code>。之后参与者等待协调者的下一条命令。</p><h4 id="第二阶段：提交阶段">第二阶段：提交阶段</h4><p>如果上一步中所有参与者的事务<code>执行成功</code>，那么协调者发送<code>commit</code>指令让参与者都<code>提交事务</code>。或者，有参与者返回的<code>执行失败</code>，则发送<code>rollback</code>给参与者，让所有参与者<code>回滚事务</code>。</p><div class="note note-warning"><p>二阶段提交存在的问题：</p><ol><li>参与者在完成第一阶段，等待协调者的下一条命令时是处于<code>阻塞状态</code>的。（<ins><strong>这是一个影响效率的大问题</strong></ins>）</li><li>如果协调者挂了，发不出指令，那么整个系统不可用</li><li>协调者在第二阶段发送提交指令后，可能因为网络等原因，有的参与者收到指令完成提交，有的参与者没收到指令，导致系统数据不一致。</li></ol></div><h3 id="三阶段提交协议">三阶段提交协议</h3><p>与二阶段提交不同，三阶段提交（Three-phase commit protocol）是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在二阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。在这里就不多做介绍了。</p><h3 id="TCC">TCC</h3><p>TCC即为Try Confirm Cancel，它也算二阶段提交的一种延伸，属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p><ul><li><p>Try：尝试待执行的业务。完成所有业务检查, 预留必须业务资源。但此时不执行事务。</p></li><li><p>Confirm：执行事务，不再做检查。</p></li><li><p>Cancel：取消执行的业务</p></li></ul><div class="note note-warning"><p>TCC存在的问题：</p><p>它将一个业务分成了三个部分，引入的时候需要系统在代码架构层面有所修改，这无疑增大了业务系统的复杂度。</p></div><h3 id="本地消息表">本地消息表</h3><p>本地消息表，通俗来说，就是节点间通过消息推送的方式来沟通事务执行。<code>主动方</code>通知<code>被动方</code>执行事务，同时<code>主动方</code>将这条通知存储到数据库，当<code>被动方</code>完成事务反馈之后更新数据库里的这条通知的状态。如果<code>主动方</code>发送通知后一段时间没收到<code>被动方</code>的反馈（数据库里通知的状态没更新），则重发数据库里的通知。</p><p>大致流程如下：</p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" srcset="/img/loading.gif"><p>其中，<code>A节点事务</code>（就是主动方）中的<code>第1</code>、<code>第2</code>步在同一事务中。如果消息数据没写入到数据库中，那业务数据也不能写入，后续流程不能执行。</p><p><strong>系统会一直尝试重发数据库里<code>没有结束</code>的消息。</strong></p><p>然后我们来看看实际应用场景中可能发生的问题：</p><ol><li>第二步，主动方的消息存数据库失败：这个上面说过了，<code>1</code>、<code>2</code>是一个事务，存入失败不会有后续流程，不会有数据一致性问题。</li><li>第三步，主动方消息发送失败：其实不影响整个流程，因为数据库里已经有这条消息，系统会一直尝试重发数据库里<code>没有结束</code>的消息。</li><li>第四步，被动方执行事务失败：程序员改好bug上线后，由于主动方会一直发这个消息，被动方还是能收到消息执行事务的。所以即使事务执行失败，修复好问题后数据仍能最终一致。</li><li>第五步，被动方反馈结果失败：下次主动方重发消息来之后，被动方再执行一次事务再尝试修改消息的状态即可。</li></ol><p>由此可知，<code>本地消息表</code> 整体的容错率还是不错的，也符合<a href="#BASE%E5%8E%9F%E5%88%99">BASE原则</a>。</p><div class="note note-warning"><p><strong>但是！这里的前提是被动方消费事务通知时是<code>幂等</code>的！！</strong> 如果被动方消费事务通知不是幂等，那主动方的每一次重发都可能造成严重的数据错乱等问题！</p></div><h3 id="最大努力通知">最大努力通知</h3><p>最大努力通知的架构流程跟 <code>本地消息表</code> 比较相似。最大努力通知要求 <code>主动方</code> 尽自己最大的努力去通知 <code>被动方</code>。即，主动方要确保自己的通知消息发送成功。</p><p>先来看看大概流程图：</p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5.png" srcset="/img/loading.gif"><ol><li>前两步跟 <code>本地消息表</code> 的一样，其实目的就是让消息在本地也有一份持久化数据，用于本地确认消息的状态。</li><li>第三步，<code>最大努力通知</code>要求消息队列中消息持久化。因为最大努力通知在主动方确认消息发出后就不会再重发了，如果消息没有持久化，消息队列挂了，消息丢了，主动方又不重发了，被动方永远收不到消息了。</li><li>第四步，诶，这里就跟 <code>本地消息表</code> 不同了。这里要求MQ在确认收到消息是返回一个 <code>ACK(一种信号)</code> ，这样才能让主动方确认自己真的发出了、自己任务完成了，更新数据库把消息标示为已发送，就再也不管了也不会重发了。</li><li>第四步如果主动方没收到MQ的 <code>ACK</code> ， 那就重发。（所以这里不能百分百保证消息不会重复发送，因为MQ可能收到了消息，只是 <code>ACK</code> 发失败了。这样主动方重发就会有重复消息。<strong>所以跟本地消息表一样，被动方消费也必须要幂等</strong>）</li><li>第五步，这里被动方要不断循环去消费消息，因为被动方如果消费失败（比如执行事务有问题），它不会让MQ删除这条消息。它自己循环消费就可以不断地重试未执行成功的事务。</li></ol><div class="note note-info"><p><code>最大努力通知</code> 与 <code>本地消息表</code> 的区别：</p><ol><li>最大努力通知侧重于 <code>主动方</code> 发出通知的能力，不在乎 <code>被动方</code> 处理事务的能力。适用于对数据一致性的时间要求不高、 <code>被动方</code> 不影响 <code>主动方</code> 业务的情况。</li><li>本地消息表则更侧重于对消息状态的控制。需要被动方处理事务完成后通知主动方更改消息的状态，不然就会一直重发消息。</li></ol></div><h2 id="总结">总结</h2><p>其实以上说的一些分布式事务方案都只能说是一种大概框架思路，我们可以根据业务场景做一些修改或者添加更多的容错机制。</p><p>打个比方，假如我们用最大努力通知来更新订单的支付状态。如果因为某些原因（比如代码bug）订单一直更新失败，那么如果让它永远不断地重试是没有意义的，用户付完钱也等不了这么久订单状态一直显示未支付。那么根据业务，我们可以设置两个容错：<ins>1.在用户订单页刷新时 <code>订单服务</code> 主动查询 <code>支付服务</code> 自己的支付状态。2.（现在很多地方在用的）用户支付时弹出一个选择框，如下图。当用户选择支付成功后再主动查询一次订单状态。</ins></p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%94%AF%E4%BB%98%E7%95%8C%E9%9D%A2.png" srcset="/img/loading.gif"><p><ins>以上例子仅供参考，主要就是想说明不要被框架的流程局限。</ins></p><p>那么以上就是这篇博客的全文了，内容其实主要还是以介绍大概思路为主。但由于本人资历尚浅，才学有限，文章中难免有错误、纰漏、不严谨之处，还请大家不吝指教。</p><p>希望文章能对读者有所帮助，共同进步。感谢阅读！</p><h2 id="参考">参考</h2><ul><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">分布式事务，这一篇就够了 | 小米信息部技术团队</a></li><li><a href="https://juejin.im/post/6844903647197806605" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他 - 掘金</a></li><li><a href="https://juejin.im/post/6844903573667446797" target="_blank" rel="noopener">常用的分布式事务解决方案 - 掘金 作者：大闲人柴毛毛</a></li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank" rel="noopener">Eventual consistency - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">Two-phase commit protocol - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">Three-phase commit protocol - Wikipedia</a></li></ul></div><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF/">技术</a> <a class="hover-with-bg" href="/categories/%E6%8A%80%E6%9C%AF/%E6%8A%80%E6%9C%AF%E6%9E%B6%E6%9E%84/">技术架构</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/%E5%88%86%E5%B8%83%E5%BC%8F/">分布式</a></div></div><p class="note note-warning">有问题欢迎评论留言讨论。文章采用 <a href="https://creativecommons.org/licenses/by-sa/4.0/deed.zh" target="_blank" rel="nofollow noopener noopener">CC BY-SA 4.0协议</a>，转载请注明出处。感谢阅读～～<br>PS: 如果文章底下评论区没有显示，可能是与github网站的连接有问题。可以刷新重试一下，或者通过关于页面的邮箱联系我。</p><div class="post-prevnext row"><article class="post-prev col-6"></article><article class="post-next col-6"><a href="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"><span class="hidden-mobile">Java线程池详解</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></article></div></div><article class="comments" id="comments"><script type="text/javascript">function loadUtterances(){var t=document.createElement("script");t.setAttribute("src","https://utteranc.es/client.js"),t.setAttribute("repo","EviLCyii/evilcyii.github.io"),t.setAttribute("issue-term","pathname"),t.setAttribute("label","utterances"),t.setAttribute("theme","github-light"),t.setAttribute("crossorigin","anonymous"),document.getElementById("comments").appendChild(t)}waitElementVisible("comments",loadUtterances)</script></article></article></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div><a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div></div></footer><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/debouncer.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:"#post-body",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:6,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","分布式事务解决方案&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script defer>window.ga=window.ga||function(){(ga.q=ga.q||[]).push(arguments)},ga.l=+new Date,ga("create","UA-165973877-1","auto"),ga("send","pageview")</script><script async src="https://www.google-analytics.com/analytics.js"></script></body></html>