<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>分布式事务解决方案</title>
    <link href="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <url>/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h2 id="什么是事务">什么是事务</h2><p>事务是执行操作的一个逻辑单位。只有在所有操作都成功的前提下，事务才算完成。否则，只要其中有任一操作失败，则整个事务失败，将退回至事务开始前的状态，像是什么也没发生。这就是事务的<code>原子性（Atomicity）</code>。除了原子性，事务还有<code>一致性（Consistency）</code>、<code>隔离性（Isolation）</code>、<code>持久性（Durability）</code>，共四个特性。简称事务的ACID特性。</p><h3 id="ACID特性">ACID特性</h3><ul><li><p><code>A 原子性</code></p><p>就如上面所说，事务执行操作要么都成功有效，要么都失败。<strong>事务中的操作不可分割。</strong></p></li><li><p><code>C 一致性</code></p><p>数据只可能是事务之前的状态或事务完成之后的状态。它不会是事务完成一半的中间状态。</p></li><li><p><code>I 隔离性</code></p><p>各个事务之间的数据状态相互隔离。比如一个事务T1有两个操作，将A变成B和将1变成2。另一个事务在查询数据的时候只可能看到T1执行成功前的状态（A、1）或者执行成功后的状态（B、2），不可能是中间状态比如（B、1)。</p></li><li><p><code>D 持久性</code></p><p>已被提交的事务如果执行成功，那么结果将永久的保留、有效。即使出现系统宕机重启，也不会影响已经完成的事务。</p></li></ul><h2 id="分布式事务概念">分布式事务概念</h2><h3 id="什么是分布式事务">什么是分布式事务</h3><p>分布式事务，顾名思义，就是在分布式系统中的事务，且事务的操作内容在不同的节点上执行。<strong>分布式事务就是为了尽可能地保证分布式中地数据一致性。</strong></p><h3 id="分布式事务与传统事务的不同">分布式事务与传统事务的不同</h3><p>传统事务的数据操作是在单一节点、单一数据库中完成的，事务中的操作一气呵成。而分布式事务的操作是在不同节点中完成，对不同节点的操作请求、以及访问各个节点的操作结果是需要通过网络传输的。 <strong>而网络传输是难免会有不稳定以及无法保证实效，从而ACID中的数据一致性很难保证。</strong> 比如某一个操作执行完成了，通知其他节点的时候网络不稳定没通知上，那么其他节点可能会认为这个操作失败了，导致其他节点数据回滚，从而各个节点数据不一致。 <strong>这就是分布式事务要解决的问题。</strong></p><h3 id="CAP原则">CAP原则</h3><p>在分布式系统中，永远绕不开CAP原则。</p><ul><li><p><code>Consistency（一致性）</code></p><p>各个节点中的数据在同一时刻能读到的数据是一致的、最新写入的。这与<a href="#ACID%E7%89%B9%E6%80%A7">ACID特性</a>的一致性概念完全不同。</p></li><li><p><code>Availability（可用性）</code></p><p>即使有部分节点不可用（比如宕机），其他可用的节点依旧能访问，整个系统依旧是保持可用的。</p></li><li><p><code>Partition tolerance（分区容错性）</code></p><p>例：有两个节点A、B，如果B节点的网络出了问题无法跟A正常通信了，那么它们俩就发生了分区。分区容错性就是指发生分区时，整个系统仍可用。</p></li></ul><p><strong>CAP 原则的精髓就是要么 AP，要么 CP，要么 AC，但是不存在 CAP。</strong></p><p>例如如果在某个分布式系统中数据无副本， 那么系统必然满足强一致性条件， 因为只有独一数据，不会出现数据不一致的情况，此时 C 和 P 两要素具备，但是如果系统发生了网络分区状况或者宕机，必然导致某些数据不可以访问，此时可用性条件就不能被满足，即在此情况下获得了 CP 系统。<ins>Zookeeper就是典型的CP系统。</ins></p><h3 id="BASE原则">BASE原则</h3><p>那么既然CAP不能三者共存，意味着一个分布式系统在CAP中必须要有所取舍。我们这里就用常规的业务系统来作例子。</p><p>在大多数业务系统，可用性是需要保证的。大型的生产环境中每个服务往往会有多个实例以此来保证系统的高可用，如果其中一个实例挂了其他实例就都用不了，那显然就不是高可用了。<strong>所以可用性是必要的。</strong> 同时，如果一个系统中的某一服务暂时不可达，这个系统就不能用的话这也会有问题的。比如说系统的非核心服务挂了，如统计服务，它就完全不可用了，用户也登录不了，那显然也是不行的。<strong>所以分区容错性也是需要保证的。</strong></p><p><strong>因此在大多数业务系统中，优先保证AP是比较常见的。当然不同的系统要根据自身的需求来决定到底如何取舍。</strong></p><p>既然我们选择了AP，那数据的实时强一致性就没有办法保证了。但是我们也不能让数据总是不一致，总需要有个办法让数据即使不是实时的，但经过一段时间最终还是要能保持一致。所以，就有了<strong>BASE原则。</strong></p><p>BASE ，是<strong>B</strong>asically <strong>A</strong>vailable, <strong>S</strong>oft state, <strong>E</strong>ventual consistency 的首字母简写。它是CAP中AP的一种衍生。</p><ul><li><p><code>BA: 基本可用</code></p><p>即使系统出现某些问题，基本的读写操作要尽可能地可用。</p></li><li><p><code>S: 软状态</code></p><p>允许系统存在数据暂时不一致的软状态。（这里就是无法保证CAP中的一致性）</p></li><li><p><code>E: 最终一致性</code></p><p>如果系统运行正常，那么在运行一段时间后，各个节点的数据会最终达成一致。</p></li></ul><p>BASE中的<code>软状态</code>和<code>最终一致性</code>就达到了上面我们想要的效果：<strong>经过一段时间延迟后数据最终还是要能保持一致。</strong></p><h3 id="分布式事务的缺点">分布式事务的缺点</h3><p>以上我们了解到，分布式事务是很难达到强一致性的，<strong>那么在对数据一致性要求高、数据间依赖关系强的地方是不适合的，这种情况最好设计成单机本地事务。同时，分布式事务也极大增加了系统的复杂性和耦合度。</strong> 这也对开发人员带来了不少挑战与麻烦。系统的设计、维护成本也会大大提高。</p><h2 id="分布式事务解决方案">分布式事务解决方案</h2><h3 id="二阶段提交协议">二阶段提交协议</h3><p>二阶段提交（Two-phase Commit protocol），简称2PC，为了使基于分布式系统架构下的所有节点在进行事务提交时保持一致性而设计的一种算法。通常，二阶段提交也被称为是一种协议。</p><p>二阶段提交算法的成立基于以下假设：</p><ol><li>该分布式系统中，存在一个节点作为协调者(Coordinator)，其他节点作为参与者(Participants)。且节点之间可以进行网络通信。</li><li>所有节点都采用预写式日志，且日志被写入后即被保持在可靠的存储设备上，即使节点损坏不会导致日志数据的消失。</li><li>所有节点不会永久性损坏，即使损坏后仍然可以恢复。</li></ol><p>二阶段提交，顾名思义，就是将分布式事务分成两个阶段：</p><h4 id="第一阶段：准备阶段">第一阶段：准备阶段</h4><p>准备阶段就是协调者询问每个参与者是否准备好各自的事务：协调者向参与者发起准备命令，那么参与者就开始创建事务，并执行事务但不提交(<code>commit</code>)。之后每个参与者返回自己的状态：<code>执行成功</code> 或者 <code>执行失败</code>。之后参与者等待协调者的下一条命令。</p><h4 id="第二阶段：提交阶段">第二阶段：提交阶段</h4><p>如果上一步中所有参与者的事务<code>执行成功</code>，那么协调者发送<code>commit</code>指令让参与者都<code>提交事务</code>。或者，有参与者返回的<code>执行失败</code>，则发送<code>rollback</code>给参与者，让所有参与者<code>回滚事务</code>。</p><div class="note note-warning"><p>二阶段提交存在的问题：</p><ol><li>参与者在完成第一阶段，等待协调者的下一条命令时是处于<code>阻塞状态</code>的。（<ins><strong>这是一个影响效率的大问题</strong></ins>）</li><li>如果协调者挂了，发不出指令，那么整个系统不可用</li><li>协调者在第二阶段发送提交指令后，可能因为网络等原因，有的参与者收到指令完成提交，有的参与者没收到指令，导致系统数据不一致。</li></ol></div><h3 id="三阶段提交协议">三阶段提交协议</h3><p>与二阶段提交不同，三阶段提交（Three-phase commit protocol）是“非阻塞”协议。三阶段提交在两阶段提交的第一阶段与第二阶段之间插入了一个准备阶段，使得原先在二阶段提交中，参与者在投票之后，由于协调者发生崩溃或错误，而导致参与者处于无法知晓是否提交或者中止的“不确定状态”所产生的可能相当长的延时的问题得以解决。在这里就不多做介绍了。</p><h3 id="TCC">TCC</h3><p>TCC即为Try Confirm Cancel，它也算二阶段提交的一种延伸，属于补偿型分布式事务。顾名思义，TCC实现分布式事务一共有三个步骤：</p><ul><li><p>Try：尝试待执行的业务。完成所有业务检查, 预留必须业务资源。但此时不执行事务。</p></li><li><p>Confirm：执行事务，不再做检查。</p></li><li><p>Cancel：取消执行的业务</p></li></ul><div class="note note-warning"><p>TCC存在的问题：</p><p>它将一个业务分成了三个部分，引入的时候需要系统在代码架构层面有所修改，这无疑增大了业务系统的复杂度。</p></div><h3 id="本地消息表">本地消息表</h3><p>本地消息表，通俗来说，就是节点间通过消息推送的方式来沟通事务执行。<code>主动方</code>通知<code>被动方</code>执行事务，同时<code>主动方</code>将这条通知存储到数据库，当<code>被动方</code>完成事务反馈之后更新数据库里的这条通知的状态。如果<code>主动方</code>发送通知后一段时间没收到<code>被动方</code>的反馈（数据库里通知的状态没更新），则重发数据库里的通知。</p><p>大致流程如下：</p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%9C%AC%E5%9C%B0%E6%B6%88%E6%81%AF%E8%A1%A8.png" srcset="/img/loading.gif"><p>其中，<code>A节点事务</code>（就是主动方）中的<code>第1</code>、<code>第2</code>步在同一事务中。如果消息数据没写入到数据库中，那业务数据也不能写入，后续流程不能执行。</p><p><strong>系统会一直尝试重发数据库里<code>没有结束</code>的消息。</strong></p><p>然后我们来看看实际应用场景中可能发生的问题：</p><ol><li>第二步，主动方的消息存数据库失败：这个上面说过了，<code>1</code>、<code>2</code>是一个事务，存入失败不会有后续流程，不会有数据一致性问题。</li><li>第三步，主动方消息发送失败：其实不影响整个流程，因为数据库里已经有这条消息，系统会一直尝试重发数据库里<code>没有结束</code>的消息。</li><li>第四步，被动方执行事务失败：程序员改好bug上线后，由于主动方会一直发这个消息，被动方还是能收到消息执行事务的。所以即使事务执行失败，修复好问题后数据仍能最终一致。</li><li>第五步，被动方反馈结果失败：下次主动方重发消息来之后，被动方再执行一次事务再尝试修改消息的状态即可。</li></ol><p>由此可知，<code>本地消息表</code> 整体的容错率还是不错的，也符合<a href="#BASE%E5%8E%9F%E5%88%99">BASE原则</a>。</p><div class="note note-warning"><p><strong>但是！这里的前提是被动方消费事务通知时是<code>幂等</code>的！！</strong> 如果被动方消费事务通知不是幂等，那主动方的每一次重发都可能造成严重的数据错乱等问题！</p></div><h3 id="最大努力通知">最大努力通知</h3><p>最大努力通知的架构流程跟 <code>本地消息表</code> 比较相似。最大努力通知要求 <code>主动方</code> 尽自己最大的努力去通知 <code>被动方</code>。即，主动方要确保自己的通知消息发送成功。</p><p>先来看看大概流程图：</p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%9C%80%E5%A4%A7%E5%8A%AA%E5%8A%9B%E9%80%9A%E7%9F%A5.png" srcset="/img/loading.gif"><ol><li>前两步跟 <code>本地消息表</code> 的一样，其实目的就是让消息在本地也有一份持久化数据，用于本地确认消息的状态。</li><li>第三步，<code>最大努力通知</code>要求消息队列中消息持久化。因为最大努力通知在主动方确认消息发出后就不会再重发了，如果消息没有持久化，消息队列挂了，消息丢了，主动方又不重发了，被动方永远收不到消息了。</li><li>第四步，MQ在确认收到消息后返回一个 <code>ACK(一种信号)</code> ，这样才能让主动方确认自己真的发出了、自己任务完成了，更新数据库把消息标示为已发送，就再也不管了也不会重发了。</li><li>第四步如果主动方没收到MQ的 <code>ACK</code> ， 那就重发。（所以这里不能百分百保证消息不会重复发送，因为MQ可能收到了消息，只是 <code>ACK</code> 发失败了。这样主动方重发就会有重复消息。<strong>所以跟本地消息表一样，被动方消费也必须要幂等</strong>）</li><li>第五步，这里被动方要不断循环去消费消息，因为被动方如果消费失败（比如执行事务有问题），它不会让MQ删除这条消息。它自己循环消费就可以不断地重试未执行成功的事务。</li></ol><div class="note note-info"><p><code>最大努力通知</code> 与 <code>本地消息表</code> 的区别：</p><ol><li>最大努力通知侧重于 <code>主动方</code> 发出通知的能力，不在乎 <code>被动方</code> 处理事务的能力。适用于对数据一致性的时间要求不高、 <code>被动方</code> 不影响 <code>主动方</code> 业务的情况。</li><li>本地消息表则更侧重于对消息状态的控制。需要被动方处理事务完成后通知主动方更改消息的状态，不然就会一直重发消息。</li></ol></div><h2 id="总结">总结</h2><p>其实以上说的一些分布式事务方案都只能说是一种大概框架思路，我们可以根据业务场景做一些修改或者添加更多的容错机制。</p><p>打个比方，假如我们用最大努力通知来更新订单的支付状态。如果因为某些原因（比如代码bug）订单一直更新失败，那么如果让它永远不断地重试是没有意义的，用户付完钱也等不了这么久订单状态一直显示未支付。那么根据业务，我们可以设置两个容错：<ins>1.在用户订单页刷新时 <code>订单服务</code> 主动查询 <code>支付服务</code> 自己的支付状态。2.（现在很多地方在用的）用户支付时弹出一个选择框，如下图。当用户选择支付成功后再主动查询一次订单状态。</ins></p><img src="/2020/08/12/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/%E6%94%AF%E4%BB%98%E7%95%8C%E9%9D%A2.png" srcset="/img/loading.gif"><p><ins>以上例子仅供参考，主要就是想说明不要被框架的流程局限。</ins></p><p>那么以上就是这篇博客的全文了，内容其实主要还是以介绍大概思路为主。但由于本人资历尚浅，才学有限，文章中难免有错误、纰漏、不严谨之处，还请大家不吝指教。</p><p>希望文章能对读者有所帮助，共同进步。感谢阅读！</p><h2 id="参考">参考</h2><ul><li><a href="https://xiaomi-info.github.io/2020/01/02/distributed-transaction/" target="_blank" rel="noopener">分布式事务，这一篇就够了 | 小米信息部技术团队</a></li><li><a href="https://juejin.im/post/6844903647197806605" target="_blank" rel="noopener">再有人问你分布式事务，把这篇扔给他 - 掘金</a></li><li><a href="https://juejin.im/post/6844903573667446797" target="_blank" rel="noopener">常用的分布式事务解决方案 - 掘金 作者：大闲人柴毛毛</a></li><li><a href="https://en.wikipedia.org/wiki/Eventual_consistency" target="_blank" rel="noopener">Eventual consistency - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Two-phase_commit_protocol" target="_blank" rel="noopener">Two-phase commit protocol - Wikipedia</a></li><li><a href="https://en.wikipedia.org/wiki/Three-phase_commit_protocol" target="_blank" rel="noopener">Three-phase commit protocol - Wikipedia</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>技术架构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java线程池详解</title>
    <link href="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary"><p>本文代码基于Oracle OpenJDK11。</p></div><h2 id="Java多线程基础">Java多线程基础</h2><h3 id="线程的生命周期">线程的生命周期</h3><p>线程在生命周期内共有五种状态。分别是：</p><ul><li><code>NEW (新建状态)</code></li><li><code>RUNNABLE (就绪状态)</code></li><li><code>RUNNING (运行状态)</code></li><li><code>BLOCKED (阻塞状态)</code></li><li><code>DEAD (终止状态)</code></li></ul><p>(一)<code>NEW (新建状态)</code>是线程被创建但未启动的状态。</p><p>创建线程的方法有三种：第一种是继承Thread类；第二种实现Runnable接口；第三种实现Callable接口；</p><div class="note note-info"><p>相比第一种，更推荐第二种方式，因为继承自Thread类往往不符合里氏代换原则，而实现Runnable接口可以使编程更加灵活，对外暴露的细节比较少，让开发人员更专注于run()方法上。</p><p>Callable比起Runnable有两点不同：一、Callable可以通过call()获取返回值。 二、call()可以抛出异常。</p></div><p>(二)<code>RUNNABLE (就绪状态)</code>是线程已经调用start()，但没有执行run()的状态。</p><p>(三)<code>RUNNING (运行状态)</code>线程正在执行run()</p><p>(四)<code>BLOCKED (阻塞状态)</code>进入此状态有一下几种情况：</p><ul><li>同步阻塞：锁被其他线程占用</li><li>主动阻塞：调用Thread的某些方法，主动让出cpu时间片。比如sleep()、join()等。</li><li>等待阻塞：执行了wait()方法</li></ul><p>(五)<code>DEAD (终止状态)</code>run()执行结束或者抛出异常退出的状态。此状态不可逆转。</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/thread-img.png" srcset="/img/loading.gif" title="Java线程流程图"><h2 id="线程池">线程池</h2><h3 id="线程池的作用">线程池的作用</h3><p>每个线程都拥有独立的程序计数器、虚拟机栈、本地方法栈，频繁地创建、销毁线程将会浪费大量的系统资源。同时，手动创建线程很难很好地支持定时线程任务、限制最大并发量等功能。所以需要线程池来管理、复用多个线程，并实现定时任务等高级功能。</p><h3 id="创建线程池">创建线程池</h3><h4 id="详解线程池构造器">详解线程池构造器</h4><p>首先，我们肯定需要知道<code>ThreadPoolExecutor</code>的实例对象里有什么，之后才能了解它的流程。先来看看<code>ThreadPoolExecutor</code>的构造器。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><span class="hljs-comment">*        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><span class="hljs-comment">*        pool</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><span class="hljs-comment">*        the core, this is the maximum time that excess idle threads</span><span class="hljs-comment">*        will wait for new tasks before terminating.</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><span class="hljs-comment">*        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><span class="hljs-comment">*        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> threadFactory the factory to use when the executor</span><span class="hljs-comment">*        creates a new thread</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> handler the handler to use when execution is blocked</span><span class="hljs-comment">*        because the thread bounds and queue capacities are reached</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                              TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                              ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                              RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre><p>每个参数的说明:</p><ol><li><p><strong>corePoolSize</strong>: 常驻线程数，也称核心线程数。常驻线程即使没有任务执行处于空闲状态也不会进入DEAD，以此来减少线程的频繁创建。这个参数的设置非常关键，因为设置如果过大将浪费资源，而过小又会导致线程创建频繁。<strong>corePoolSize的值不能小于0，否则将抛出<code>IllegalArgumentException</code>异常。</strong></p></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。最大线程数不能小于常驻线程数(corePoolSize)。</p></li><li><p><strong>keepAliveTime</strong>: 空闲线程存活时间。当线程池的线程数量大于常驻线程数时，线程执行完任务进入空闲状态并持续keepAliveTime时间后会被销毁，直到只剩下corePoolSize数量的线程为止。如果在keepAliveTime时间内线程又有新的任务执行是不会被销毁的。<ins><strong>需要注意的是如果<code>allowCoreThreadTimeOut</code>参数设置为<code>true</code>时，常驻线程也会被销毁。</strong></ins></p></li><li><p><strong>unit</strong>: keepAliveTime的时间单位。</p></li><li><p><strong>workQueue</strong>: 缓存队列。调用了<code>execute</code>方法但还未执行的任务将被存至缓存队列中。</p></li><li><p><strong>threadFactory</strong>: 配置创建线程的工厂。创建新线程的时候调用的工厂。</p></li><li><p><strong>handler</strong>: 执行拒绝策略的对象。当线程池的容量已经达到上限且缓存队列也无法容纳的时候，将由handler执行拒绝策略。</p></li></ol><div class="note note-warning"><p>在实际开发中，强烈推荐配置自定义的<code>threadFactory</code>。这在<a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener"><ins>Alibaba的《Java开发手册》</ins></a>中也是<code>强制要求</code>的内容。自定义threadFactory可以指定有意义的线程名称，对应用在出错时回溯有着非常重要的意义！</p></div><p><strong>了解了各个参数的作用，我们开始来创建ThreadPoolExecutor实例对象。</strong></p><h4 id="Executors创建线程池-不推荐">Executors创建线程池(不推荐)</h4><p>JDK中自带<code>Executors</code>工厂类可以方便地创建线程池。它可以创建三种线程池包装对象：<code>ForkJoinPool</code>、<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>。他们之间的关系如下图:</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/threadpoolclasses.png" srcset="/img/loading.gif" title="ThreadPoolExecutor相关类图"><p>不推荐使用<code>Executors</code>的原因是它的参数配置不够灵活，虽然这节省了开发人员的很多工作，<ins><strong>但也同时无法很好地贴合自身业务需求，甚至带来了OOM的风险。</strong></ins><code>Executors</code>的默认拒绝策略也过于简单。</p><h4 id="手动创建线程池-推荐">手动创建线程池(推荐)</h4><p>虽然说是手动创建线程池，但其实自己自定义一个设计合理、能贴合业务需求的线程工厂来取代<code>Executors</code>工厂类当然也是完全没问题的。</p><p>先实现一个简单的<code>ThreadFactory</code>线程工厂:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String threadName = <span class="hljs-string">"My_Thread_"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;        String name = threadName + atomicInteger.getAndIncrement();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, name);    &#125;&#125;</code></pre><p>再简单地实现一个<code>RejectedExecutionHandler</code>拒绝策略处理器:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRejectedExecutionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;        System.out.println(<span class="hljs-string">"线程被拒绝："</span>+ executor.toString());    &#125;&#125;</code></pre><p>接下来我们就可以创建自己想要的<code>ThreadPoolExecutor</code>对象:</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 创建一个核心线程数为2、最大线程数为5、存活时间为10秒、最大队列为2的线程池</span><span class="hljs-comment"> */</span>ThreadPoolExecutor threadPoolExecutor =                <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>,                        TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">2</span>),                        <span class="hljs-keyword">new</span> MyThreadFactory(), <span class="hljs-keyword">new</span> MyRejectedExecutionHandler());</code></pre><p>通过<code>threadPoolExecutor.execute(...)</code>方法即可执行线程。</p><h3 id="线程池源码">线程池源码</h3><p>现在我们知道了如何创建一个符合自己业务需要的线程池，接下来我们了解一下线程池创建线程的流程。要知道线程池是如何工作的，我们就需要细品一下它的源码。</p><p>首先我们要了解线程池有哪几种状态：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_MASK = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre><p>平常习惯使用常量、枚举来标示状态的同学（比如我）刚看到这种定义状态的代码第一反应可能会有点懵。但当我们捡起位移运算等知识，再配合源码的注释看，还是能看明白的。这段代码主要就表达了两个意思：</p><ol><li><p><code>int</code>类型是32位，在线程池中最左边的3位用来表示状态，右边的29位用来表示线程数。<strong>所以一个线程池最大的线程数为2<sup>29</sup>。</strong></p></li><li><p>线程池一共有五种状态，并且五种状态是int类型存储，有大小排序。从小到大分别为：</p></li></ol><ul><li>RUNNING: 接受新作业并且处理队列中的作业</li><li>SHUTDOWN: 不再接受新作业，但会处理队列中的作业</li><li>STOP: 不再接受新作业，不再处理队列中的作业，中断正在执行的作业</li><li>TIDYING: 所有作业都已经终止(运行结束或抛出异常或被中断)，线程数变为0。在线程变为TIDYING状态时会调用<code>terminated()</code></li><li>TERMINATED: <code>terminated()</code>调用完成，变为此状态</li></ul><p>线程池状态间的变换如图所示：</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.jpg" srcset="/img/loading.gif" title="线程池流程图"><p>了解了线程池有哪些状态后，我们来看看核心方法<code>execute</code>的源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 执行可分为3步:</span><span class="hljs-comment">     * 1. 如果当前线程数量少于corePoolSize，则尝试addWorker创建新的线程来执行任务（成功的话方法就结束返回）。</span><span class="hljs-comment">     * 调用addWorker方法时原子性检查线程池状态和线程数。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 2. 如果线程数量不少于corePoolSize，或者尝试addWorker创建新的线程失败</span><span class="hljs-comment">     *（原因可能是addWorker期间线程池被关闭了或者被别的作业先创建了线程导致线程池满了），则任务进入队列中。</span><span class="hljs-comment">     * 如果如果任务成功进入队列，那么我们仍需二次确认我们是否能添加线程（因为上次确认后有可能有线程已经销毁）、及线程池是否已经关闭。</span><span class="hljs-comment">     * 如果线程池已经关闭，则拒绝执行任务，执行拒绝策略。如果检查都通过，成功创建新的线程。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 3. 如果第二步中作业不能进入到队列，那么我们直接尝试将作业创建一个新的线程。失败了则执行拒绝策略。</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// 获取线程池状态</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">// 如果当前线程数量少于corePoolSize</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 尝试创建常驻线程(第二个参数即是否为常驻线程)</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 如果尝试失败，那么有可能是线程池被关闭，再次拿线程池状态</span>        c = ctl.get();    &#125;    <span class="hljs-comment">// 检查确认线程池是否在运行中，并将线程尝试加入队列</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">// 再次确认</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果不在运行了就移除任务，并执行拒绝策略</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        <span class="hljs-comment">// 如果已经没有线程，则新建线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">// 将线程尝试加入队列失败，尝试直接添加线程执行</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre><p>可以看到源码中多次查询线程池的运行状态，以检查JVM执行代码过程中线程池状态可能发生的突然改变。</p><p>下面看看同为线程池核心方法的<code>addWorker</code>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask 字面意思为“第一个作业”。即创建线程后执行的任务。</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core 是否为核心线程。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    <span class="hljs-comment">// 跳转位置标记。相当于C语言的goto后跟的位置。</span>    retry:    <span class="hljs-comment">// 拿到线程池当前的状态，进入循环。</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = ctl.get();;) &#123;        <span class="hljs-comment">// 如果线程池不在RUNNING状态，并且已至少在STOP状态或者firstTask不为空或者队列为空的情况下</span>        <span class="hljs-comment">// 返回失败</span>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)            &amp;&amp; (runStateAtLeast(c, STOP)                || firstTask != <span class="hljs-keyword">null</span>                || workQueue.isEmpty()))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 如果线程池的线程数已达上限，返回失败</span>            <span class="hljs-keyword">if</span> (workerCountOf(c)                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// CAS将线程池线程数加1</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-comment">// 跳转至retry位置</span>                <span class="hljs-keyword">break</span> retry;            c = ctl.get();            <span class="hljs-comment">// 如果线程数加失败了，查看线程池状态是否关闭了</span>            <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// 如果线程池没关闭，那就是CAS失败了，说明期间线程数变动了，重新执行循环</span>        &#125;    &#125;    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 将任务、线程封装到Worker对象中。Worker构造器中使用了我们配置的ThreadFactory来新建线程</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-comment">// 获取上一行代码中Worker构造器里初始化的Thread对象</span>        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// mainLock是线程池的主锁，当敏感操作时使用它</span>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">int</span> c = ctl.get();                <span class="hljs-keyword">if</span> (isRunning(c) ||                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-comment">// 文章上面说过线程的状态，这里判断线程是否为NEW状态。</span>                    <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 将worker加入队列</span>                    workers.add(w);                    workerAdded = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (! workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre><p>以上就是线程池中最重要的执行、添加线程的方法源码。源码有些生涩难懂，有些部分也有些超出常理，比如<code>for(;;)</code>这样的代码需要程序员对代码的可控性有非常精细的把握，不然就可能发生死循环。</p><p>还有一些方法比如<code>shutdown()</code>等，在这里就不一一展开了。它们相对于以上新增线程的代码复杂度稍微低一些，更容易看懂。</p><p><strong>另外，也建议读者看看线程池中内部类<code>Worker</code>的源码，源码比较简单易懂。它将线程、作业做了封装，在线程池中也是举足轻重的一部分。</strong></p><h2 id="总结">总结</h2><p>多线程一直是大型系统中最能提高性能，又最能增加bug的部分。要能合理、有效地使用多线程，线程池是绕不开的。其实线程池源码在仔细阅读后就会发现，线程池离我们也并不遥远。理解了线程池的原理、运行机制之后，相信对我们的多线程应用编写会有所帮助。</p><p>在使用线程池中，线程池参数的配置是十分重要的。合理地配置参数能让线程池发挥最大性能、吃最少资源。</p><p>最后，别忘了将线程池在生命周期结束时<code>shutdown()</code>，不然应用程序主线程结束了线程池仍会继续运行。</p><p>由于本人资历尚浅，才学有限，文章中难免有错误、纰漏、不严谨之处，还请大家不吝指教。希望文章能对读者有所帮助，共同进步。感谢阅读！</p><h2 id="参考">参考</h2><ul><li><a href="https://item.jd.com/12445838.html" target="_blank" rel="noopener">《码出高效 Java开发手册》 —— 杨冠宝（孤尽） 高海彗（鸣莎）著</a></li><li><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">《Java开发手册（嵩山版）》</a> —— alibaba在github开源内容</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git子模块——在Git中再嵌套一个Git</title>
    <link href="/2020/05/13/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <url>/2020/05/13/git%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>最近终于动手把博客好好地弄起来了！第一篇博文还是忍不住感叹一下～</p><p>第一篇文章，就从我部署博客遇到的问题说起。</p><h2 id="问题描述">问题描述</h2><div class="note note-primary"><p>友情提示：本文可能需要有一定的Git基础才能比较好理解。如果没接触过Git的同学推荐先学习Git的基础内容、熟练Git的基本使用。网上上手教程很多，如果想更进一步熟悉Git、了解Git的设计原理，更推荐<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方文档-Git Book</a></p></div><p>在搭建博客的过程中，我们往往为了美观会使用<ins>第三方主题</ins>。然后我遇到了这样一个问题：我想在我的Hexo博客中，<ins>尽可能方便地保持我的主题是最新的</ins>。</p><p>（我真的非常享受体会各种软件的各种新功能hahaha）</p><p>于是我就想在我已经构建Git的博客代码中，<code>git clone</code> 拿到主题的最新代码，并且可以更新。但是我的博客代码本身就已经有git版本管理，这就涉及到了Git子模块内容。</p><div class="note note-warning"><p>如果只是想拿一次主题代码（或者说子项目代码），而并不打算以后同步更新远程仓库的话，是无需使用Git子模块的。这种情景简单的办法有：拉到主题（子项目代码）后删除子项目目录中的.git文件夹（及.gitignore等git相关文件）即可。请结合好自己的需求。</p></div><div class="note note-info"><p>为了方便说明，我后面用<code>父项目</code>代表<code>博客</code>，<code>子项目</code>代表博客里的<code>主题</code></p></div><h3 id="直接克隆会遇到的问题">直接克隆会遇到的问题</h3><p>首先，如果我们在一个Git项目中直接再<code>git clone</code>一个项目看看会有什么效果：</p><pre><code class="hljs bash"><span class="hljs-comment"># 先创建一个父项目，初始化Git</span>$ <span class="hljs-built_in">cd</span> parent$ git init已初始化空的 Git 仓库于 /path/to/parent<span class="hljs-comment"># 放一个测试用的文件id，存入1</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1'</span> &gt; id<span class="hljs-comment"># 远程拉一个子项目代码</span>$ git <span class="hljs-built_in">clone</span> https://github.com/your/SubProject sub$ git status位于分支 master尚无提交未跟踪的文件:  （使用 <span class="hljs-string">"git add &lt;文件&gt;..."</span> 以包含要提交的内容）        id        sub/提交为空，但是存在尚未跟踪的文件（使用 <span class="hljs-string">"git add"</span> 建立跟踪）<span class="hljs-comment"># 修改子项目内容</span>$ <span class="hljs-built_in">cd</span> son$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'sub'</span> &gt; name<span class="hljs-comment"># 我们添加文件到git就会报提示，大致内容就是：“你在本库（父项目）中添加了其他库（子项目），</span><span class="hljs-comment"># 如果你在其他地方clone父项目，将不会包含子项目的内容。你可能要用到git submodule。”</span>$ git all --all<span class="hljs-comment"># 提示：You've added another git repository inside your current repository.</span><span class="hljs-comment"># 提示：Clones of the outer repository will not contain the contents of</span><span class="hljs-comment"># 提示：the embedded repository and will not know how to obtain it.</span><span class="hljs-comment"># 提示：If you meant to add a submodule, use:</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：  git submodule add &lt;url&gt; son</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：If you added this path by mistake, you can remove it from the</span><span class="hljs-comment"># 提示：index with:</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：  git rm --cached son</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：See "git help submodule" for more information.</span><span class="hljs-comment"># 这时我们可以看到son/name并没有被添加到git，只有个son文件夹</span>$ git status位于分支 master尚无提交要提交的变更：  （使用 <span class="hljs-string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）        新文件：   id        新文件：   sub</code></pre><p>经过实践，我们发现直接在父项目中<code>git clone</code>子项目是无法被父项目的Git库感知和捕捉的，换言之就是父项目的Git无法添加子项目的代码。这样的后果就是当别处要<code>git clone</code>你的项目时（或着你的项目要提交到远程仓库时），<ins>别人拿不到项目中的子项目代码</ins>。</p><p>因此我们根据上面Git给的提示，学习学习<code>Git子模块</code>。</p><h2 id="Git子模块">Git子模块</h2><div class="note note-primary"><p>主要参考自<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a></p></div><div class="note note-light"><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。——Git官网</p></div><h3 id="添加Git子模块">添加Git子模块</h3><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。使用<code>git submodule add</code>命令。</p><pre><code class="hljs bash">$ git submodule add https://github.com/your/SubProject sub</code></pre><p>此时会生成一个<code>.gitmodules</code>文件，保存了项目 URL 与已经拉取的本地目录之间的映射：</p><pre><code class="hljs conf">[submodule &quot;sub&quot;]  path &#x3D; sub  url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;your&#x2F;SubProject</code></pre><div class="note note-warning"><p>如果有多个子模块，该文件中就会有多条记录。 <ins>要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。</ins> 这就是克隆该项目的人知道去哪获得子模块的原因。</p></div><p>输入<code>git submodule status</code>命令即可以查看子模块的状态</p><div class="note note-warning"><p>需要注意的是<code>git submodule add</code>会自动将远程的代码拉到本地。此时你会发现你添加完子模块，子模块的代码已经拉到本地了。</p><p>但如果<code>git clone</code>父项目是不会拉到子项目的内容的。原因是父模块的Git只保存了子模块的版本信息，而并没有保存子模块的代码内容。<code>git clone</code>父模块后需要<code>git submodule init</code>和<code>git submodule update</code>才能根据子模块的版本信息拉取对应的子模块内容。这块后续会说到。</p></div><p>此时我们的子模块就添加完成了。</p><h3 id="提交父项目至远程库">提交父项目至远程库</h3><p>假设我们只是拿子项目的内容使用，暂时不更改子项目内容。此时我们像平时一样地提交父项目内容：</p><pre><code class="hljs bash">$ git add --all$ git commmit -am <span class="hljs-string">'添加子项目'</span>[master fb9093c] 添加子项目 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub</code></pre><div class="note note-warning"><p>注意<code>sub</code>记录的<code>160000</code>模式。这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，<ins>而非将它记录成一个子目录或者一个文件。</ins>（这也是为什么<code>git clone</code>父项目的代码无法直接拿到子项目内容的原因！）</p></div><pre><code class="hljs bash">$ git push origin master</code></pre><h3 id="克隆含有子模块的项目">克隆含有子模块的项目</h3><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/your/MainProject$ <span class="hljs-built_in">cd</span> MainProject<span class="hljs-comment">#此时克隆父项目完毕，sub为子项目文件夹</span>$ ls -a.git .gitmodule id sub<span class="hljs-comment"># 进入子项目文件夹会发现没有子项目内容，是空的</span>$ <span class="hljs-built_in">cd</span> sub$ ls</code></pre><div class="note note-info"><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而<code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p></div><pre><code class="hljs bash">$ git submodule initSubmodule <span class="hljs-string">'sub'</span> (https://github.com/your/SubProject) registered <span class="hljs-keyword">for</span> path <span class="hljs-string">'sub'</span>$ git submodule update</code></pre><p>现在<code>sub</code>子目录是处在和之前提交时相同的状态了。</p><p>不过还有更简单一点的方式。 如果给<code>git clone</code>命令传递<code>--recurse-submodules</code>选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</p><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --recurse-submodules https://github.com/your/MainProjectCloning...</code></pre><p>如果你已经克隆了项目但忘记了<code>--recurse-submodules</code>，那么可以运行<code>git submodule update --init</code> 将<code>git submodule init</code>和<code>git submodule update</code>合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块， 请使用简明的<code>git submodule update --init --recursive</code>。</p><h3 id="Git子模块的使用">Git子模块的使用</h3><p>在Git子模块目录中，你可以像往常一样使用<code>git fetch</code>,<code>git merge</code>,<code>git diff</code>（在父目录使用<code>git diff --submodule</code>）等功能。就跟普通的Git模块使用起来差不多，这里就不多介绍了。在父目录可以用<code>git submodule update --remote</code>来更新子模块，此命令默认会假定你想要更新并检出子模块仓库的<code>master</code>分支。</p><h3 id="发布子模块改动">发布子模块改动</h3><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p><p>可以在子模块使用<code>git diff</code>命令查看改动。</p><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦， 因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。</p><p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。<code>git push</code>命令接受可以设置为 “check” 或 “on-demand” 的<code>--recurse-submodules</code>参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使<code>push</code>操作失败。</p><pre><code class="hljs bash">$ git push --recurse-submodules=checkThe following submodule paths contain changes that cannot be found on any remote:  subPlease try  git push --recurse-submodules=on-demandor <span class="hljs-built_in">cd</span> to the path and use  git pushto push them to a remote.</code></pre><p>也就是说<code>--recurse-submodules=check</code>的时候，子项目没有提交是会不允许父项目提交的。如果把&quot;check&quot;改成&quot;on-demand&quot;，那Git会在提交父项目前先提交子项目。</p><pre><code class="hljs bash">$ git push --recurse-submodules=on-demandPushing submodule <span class="hljs-string">'sub'</span>Counting objects: 9, <span class="hljs-keyword">done</span>.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), <span class="hljs-keyword">done</span>.Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.Total 9 (delta 3), reused 0 (delta 0)To https://github.com/your/SubProject   c75e92a..82d2ad3  stable -&gt; stableCounting objects: 2, <span class="hljs-keyword">done</span>.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), <span class="hljs-keyword">done</span>.Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.Total 2 (delta 1), reused 0 (delta 0)To https://github.com/your/MainProject   3d6d338..9a377d1  master -&gt; master</code></pre><div class="note note-warning"><p>如果不推送子模块就只推送父模块，那子模块的内容别人可能会获取不到。因为父模块保存的子模块的版本只在你本地存在。</p></div><h2 id="结语">结语</h2><p>以上就是子模块的一些基础概念跟内容了。这个设计也很好地解决了我的需求，Git真的是非常强大的工具。</p><p>本文介绍子模块相关的内容有限，想要更多更详细的内容推荐<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a>。</p><h2 id="参考">参考</h2><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
