<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java线程池详解</title>
    <link href="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/"/>
    <url>/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<div class="note note-primary"><p>本文代码基于Oracle OpenJDK11。</p></div><h2 id="Java多线程基础">Java多线程基础</h2><h3 id="线程的生命周期">线程的生命周期</h3><p>线程在生命周期内共有五种状态。分别是：</p><ul><li><code>NEW (新建状态)</code></li><li><code>RUNNABLE (就绪状态)</code></li><li><code>RUNNING (运行状态)</code></li><li><code>BLOCKED (阻塞状态)</code></li><li><code>DEAD (终止状态)</code></li></ul><p>(一)<code>NEW (新建状态)</code>是线程被创建但未启动的状态。</p><p>创建线程的方法有三种：第一种是继承Thread类；第二种实现Runnable接口；第三种实现Callable接口；</p><div class="note note-info"><p>相比第一种，更推荐第二种方式，因为继承自Thread类往往不符合里氏代换原则，而实现Runnable接口可以使编程更加灵活，对外暴露的细节比较少，让开发人员更专注于run()方法上。</p><p>Callable比起Runnable有两点不同：一、Callable可以通过call()获取返回值。 二、call()可以抛出异常。</p></div><p>(二)<code>RUNNABLE (就绪状态)</code>是线程已经调用start()，但没有执行run()的状态。</p><p>(三)<code>RUNNING (运行状态)</code>线程正在执行run()</p><p>(四)<code>BLOCKED (阻塞状态)</code>进入此状态有一下几种情况：</p><ul><li>同步阻塞：锁被其他线程占用</li><li>主动阻塞：调用Thread的某些方法，主动让出cpu时间片。比如sleep()、join()等。</li><li>等待阻塞：执行了wait()方法</li></ul><p>(五)<code>DEAD (终止状态)</code>run()执行结束或者抛出异常退出的状态。此状态不可逆转。</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/thread-img.png" srcset="/img/loading.gif" title="Java线程流程图"><h2 id="线程池">线程池</h2><h3 id="线程池的作用">线程池的作用</h3><p>每个线程都拥有独立的程序计数器、虚拟机栈、本地方法栈，频繁地创建、销毁线程将会浪费大量的系统资源。同时，手动创建线程很难很好地支持定时线程任务、限制最大并发量等功能。所以需要线程池来管理、复用多个线程，并实现定时任务等高级功能。</p><h3 id="创建线程池">创建线程池</h3><h4 id="详解线程池构造器">详解线程池构造器</h4><p>首先，我们肯定需要知道<code>ThreadPoolExecutor</code>的实例对象里有什么，之后才能了解它的流程。先来看看<code>ThreadPoolExecutor</code>的构造器。</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> corePoolSize the number of threads to keep in the pool, even</span><span class="hljs-comment">*        if they are idle, unless &#123;<span class="hljs-doctag">@code</span> allowCoreThreadTimeOut&#125; is set</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> maximumPoolSize the maximum number of threads to allow in the</span><span class="hljs-comment">*        pool</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> keepAliveTime when the number of threads is greater than</span><span class="hljs-comment">*        the core, this is the maximum time that excess idle threads</span><span class="hljs-comment">*        will wait for new tasks before terminating.</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> unit the time unit for the &#123;<span class="hljs-doctag">@code</span> keepAliveTime&#125; argument</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> workQueue the queue to use for holding tasks before they are</span><span class="hljs-comment">*        executed.  This queue will hold only the &#123;<span class="hljs-doctag">@code</span> Runnable&#125;</span><span class="hljs-comment">*        tasks submitted by the &#123;<span class="hljs-doctag">@code</span> execute&#125; method.</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> threadFactory the factory to use when the executor</span><span class="hljs-comment">*        creates a new thread</span><span class="hljs-comment">* <span class="hljs-doctag">@param</span> handler the handler to use when execution is blocked</span><span class="hljs-comment">*        because the thread bounds and queue capacities are reached</span><span class="hljs-comment">*/</span><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><span class="hljs-function"><span class="hljs-params">                              <span class="hljs-keyword">long</span> keepAliveTime,</span></span><span class="hljs-function"><span class="hljs-params">                              TimeUnit unit,</span></span><span class="hljs-function"><span class="hljs-params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span><span class="hljs-function"><span class="hljs-params">                              ThreadFactory threadFactory,</span></span><span class="hljs-function"><span class="hljs-params">                              RejectedExecutionHandler handler)</span> </span>&#123;    <span class="hljs-keyword">if</span> (corePoolSize &lt; <span class="hljs-number">0</span> ||        maximumPoolSize &lt;= <span class="hljs-number">0</span> ||        maximumPoolSize &lt; corePoolSize ||        keepAliveTime &lt; <span class="hljs-number">0</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException();    <span class="hljs-keyword">if</span> (workQueue == <span class="hljs-keyword">null</span> || threadFactory == <span class="hljs-keyword">null</span> || handler == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-keyword">this</span>.corePoolSize = corePoolSize;    <span class="hljs-keyword">this</span>.maximumPoolSize = maximumPoolSize;    <span class="hljs-keyword">this</span>.workQueue = workQueue;    <span class="hljs-keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);    <span class="hljs-keyword">this</span>.threadFactory = threadFactory;    <span class="hljs-keyword">this</span>.handler = handler;&#125;</code></pre><p>每个参数的说明:</p><ol><li><p><strong>corePoolSize</strong>: 常驻线程数，也称核心线程数。常驻线程即使没有任务执行处于空闲状态也不会进入DEAD，以此来减少线程的频繁创建。这个参数的设置非常关键，因为设置如果过大将浪费资源，而过小又会导致线程创建频繁。<strong>corePoolSize的值不能小于0，否则将抛出<code>IllegalArgumentException</code>异常。</strong></p></li><li><p><strong>maximumPoolSize</strong>: 线程池允许创建的最大线程数。最大线程数不能小于常驻线程数(corePoolSize)。</p></li><li><p><strong>keepAliveTime</strong>: 空闲线程存活时间。当线程池的线程数量大于常驻线程数时，线程执行完任务进入空闲状态并持续keepAliveTime时间后会被销毁，直到只剩下corePoolSize数量的线程为止。如果在keepAliveTime时间内线程又有新的任务执行是不会被销毁的。<ins><strong>需要注意的是如果<code>allowCoreThreadTimeOut</code>参数设置为<code>true</code>时，常驻线程也会被销毁。</strong></ins></p></li><li><p><strong>unit</strong>: keepAliveTime的时间单位。</p></li><li><p><strong>workQueue</strong>: 缓存队列。调用了<code>execute</code>方法但还未执行的任务将被存至缓存队列中。</p></li><li><p><strong>threadFactory</strong>: 配置创建线程的工厂。创建新线程的时候调用的工厂。</p></li><li><p><strong>handler</strong>: 执行拒绝策略的对象。当线程池的容量已经达到上限且缓存队列也无法容纳的时候，将由handler执行拒绝策略。</p></li></ol><div class="note note-warning"><p>在实际开发中，强烈推荐配置自定义的<code>threadFactory</code>。这在<a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener"><ins>Alibaba的《Java开发手册》</ins></a>中也是<code>强制要求</code>的内容。自定义threadFactory可以指定有意义的线程名称，对应用在出错时回溯有着非常重要的意义！</p></div><p><strong>了解了各个参数的作用，我们开始来创建ThreadPoolExecutor实例对象。</strong></p><h4 id="Executors创建线程池-不推荐">Executors创建线程池(不推荐)</h4><p>JDK中自带<code>Executors</code>工厂类可以方便地创建线程池。它可以创建三种线程池包装对象：<code>ForkJoinPool</code>、<code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code>。他们之间的关系如下图:</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/threadpoolclasses.png" srcset="/img/loading.gif" title="ThreadPoolExecutor相关类图"><p>不推荐使用<code>Executors</code>的原因是它的参数配置不够灵活，虽然这节省了开发人员的很多工作，<ins><strong>但也同时无法很好地贴合自身业务需求，甚至带来了OOM的风险。</strong></ins><code>Executors</code>的默认拒绝策略也过于简单。</p><h4 id="手动创建线程池-推荐">手动创建线程池(推荐)</h4><p>虽然说是手动创建线程池，但其实自己自定义一个设计合理、能贴合业务需求的线程工厂来取代<code>Executors</code>工厂类当然也是完全没问题的。</p><p>先实现一个简单的<code>ThreadFactory</code>线程工厂:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThreadFactory</span> </span>&#123;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String threadName = <span class="hljs-string">"My_Thread_"</span>;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thread <span class="hljs-title">newThread</span><span class="hljs-params">(Runnable r)</span> </span>&#123;        String name = threadName + atomicInteger.getAndIncrement();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thread(r, name);    &#125;&#125;</code></pre><p>再简单地实现一个<code>RejectedExecutionHandler</code>拒绝策略处理器:</p><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRejectedExecutionHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectedExecutionHandler</span> </span>&#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejectedExecution</span><span class="hljs-params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;        System.out.println(<span class="hljs-string">"线程被拒绝："</span>+ executor.toString());    &#125;&#125;</code></pre><p>接下来我们就可以创建自己想要的<code>ThreadPoolExecutor</code>对象:</p><pre><code class="hljs java"><span class="hljs-comment">/*</span><span class="hljs-comment"> * 创建一个核心线程数为2、最大线程数为5、存活时间为10秒、最大队列为2的线程池</span><span class="hljs-comment"> */</span>ThreadPoolExecutor threadPoolExecutor =                <span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>,                        TimeUnit.SECONDS, <span class="hljs-keyword">new</span> LinkedBlockingDeque&lt;&gt;(<span class="hljs-number">2</span>),                        <span class="hljs-keyword">new</span> MyThreadFactory(), <span class="hljs-keyword">new</span> MyRejectedExecutionHandler());</code></pre><p>通过<code>threadPoolExecutor.execute(...)</code>方法即可执行线程。</p><h3 id="线程池源码">线程池源码</h3><p>现在我们知道了如何创建一个符合自己业务需要的线程池，接下来我们了解一下线程池创建线程的流程。要知道线程池是如何工作的，我们就需要细品一下它的源码。</p><p>首先我们要了解线程池有哪几种状态：</p><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>));<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_MASK = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> RUNNING    = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SHUTDOWN   =  <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> STOP       =  <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TIDYING    =  <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS;<span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> TERMINATED =  <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS;</code></pre><p>平常习惯使用常量、枚举来标示状态的同学（比如我）刚看到这种定义状态的代码第一反应可能会有点懵。但当我们捡起位移运算等知识，再配合源码的注释看，还是能看明白的。这段代码主要就表达了两个意思：</p><ol><li><p><code>int</code>类型是32位，在线程池中最左边的3位用来表示状态，右边的29位用来表示线程数。<strong>所以一个线程池最大的线程数为2<sup>29</sup>。</strong></p></li><li><p>线程池一共有五种状态，并且五种状态是int类型存储，有大小排序。从小到大分别为：</p></li></ol><ul><li>RUNNING: 接受新作业并且处理队列中的作业</li><li>SHUTDOWN: 不再接受新作业，但会处理队列中的作业</li><li>STOP: 不再接受新作业，不再处理队列中的作业，中断正在执行的作业</li><li>TIDYING: 所有作业都已经终止(运行结束或抛出异常或被中断)，线程数变为0。在线程变为TIDYING状态时会调用<code>terminated()</code></li><li>TERMINATED: <code>terminated()</code>调用完成，变为此状态</li></ul><p>线程池状态间的变换如图所示：</p><img src="/2020/07/22/Java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%AF%A6%E8%A7%A3/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%8A%B6%E6%80%81.jpg" srcset="/img/loading.gif" title="线程池流程图"><p>了解了线程池有哪些状态后，我们来看看核心方法<code>execute</code>的源码：</p><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();    <span class="hljs-comment">/*</span><span class="hljs-comment">     * 执行可分为3步:</span><span class="hljs-comment">     * 1. 如果当前线程数量少于corePoolSize，则尝试addWorker创建新的线程来执行任务（成功的话方法就结束返回）。</span><span class="hljs-comment">     * 调用addWorker方法时原子性检查线程池状态和线程数。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 2. 如果线程数量不少于corePoolSize，或者尝试addWorker创建新的线程失败</span><span class="hljs-comment">     *（原因可能是addWorker期间线程池被关闭了或者被别的作业先创建了线程导致线程池满了），则任务进入队列中。</span><span class="hljs-comment">     * 如果如果任务成功进入队列，那么我们仍需二次确认我们是否能添加线程（因为上次确认后有可能有线程已经销毁）、及线程池是否已经关闭。</span><span class="hljs-comment">     * 如果线程池已经关闭，则拒绝执行任务，执行拒绝策略。如果检查都通过，成功创建新的线程。</span><span class="hljs-comment">     *</span><span class="hljs-comment">     * 3. 如果第二步中作业不能进入到队列，那么我们直接尝试将作业创建一个新的线程。失败了则执行拒绝策略。</span><span class="hljs-comment">     */</span>    <span class="hljs-comment">// 获取线程池状态</span>    <span class="hljs-keyword">int</span> c = ctl.get();    <span class="hljs-comment">// 如果当前线程数量少于corePoolSize</span>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;        <span class="hljs-comment">// 尝试创建常驻线程(第二个参数即是否为常驻线程)</span>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))            <span class="hljs-keyword">return</span>;        <span class="hljs-comment">// 如果尝试失败，那么有可能是线程池被关闭，再次拿线程池状态</span>        c = ctl.get();    &#125;    <span class="hljs-comment">// 检查确认线程池是否在运行中，并将线程尝试加入队列</span>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;        <span class="hljs-comment">// 再次确认</span>        <span class="hljs-keyword">int</span> recheck = ctl.get();        <span class="hljs-comment">// 如果不在运行了就移除任务，并执行拒绝策略</span>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))            reject(command);        <span class="hljs-comment">// 如果已经没有线程，则新建线程</span>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);    &#125;    <span class="hljs-comment">// 将线程尝试加入队列失败，尝试直接添加线程执行</span>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))        reject(command);&#125;</code></pre><p>可以看到源码中多次查询线程池的运行状态，以检查JVM执行代码过程中线程池状态可能发生的突然改变。</p><p>下面看看同为线程池核心方法的<code>addWorker</code>源码：</p><pre><code class="hljs java"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> firstTask 字面意思为“第一个作业”。即创建线程后执行的任务。</span><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> core 是否为核心线程。</span><span class="hljs-comment"> */</span><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;    <span class="hljs-comment">// 跳转位置标记。相当于C语言的goto后跟的位置。</span>    retry:    <span class="hljs-comment">// 拿到线程池当前的状态，进入循环。</span>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> c = ctl.get();;) &#123;        <span class="hljs-comment">// 如果线程池不在RUNNING状态，并且已至少在STOP状态或者firstTask不为空或者队列为空的情况下</span>        <span class="hljs-comment">// 返回失败</span>        <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN)            &amp;&amp; (runStateAtLeast(c, STOP)                || firstTask != <span class="hljs-keyword">null</span>                || workQueue.isEmpty()))            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;        <span class="hljs-keyword">for</span> (;;) &#123;            <span class="hljs-comment">// 如果线程池的线程数已达上限，返回失败</span>            <span class="hljs-keyword">if</span> (workerCountOf(c)                &gt;= ((core ? corePoolSize : maximumPoolSize) &amp; COUNT_MASK))                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;            <span class="hljs-comment">// CAS将线程池线程数加1</span>            <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))                <span class="hljs-comment">// 跳转至retry位置</span>                <span class="hljs-keyword">break</span> retry;            c = ctl.get();            <span class="hljs-comment">// 如果线程数加失败了，查看线程池状态是否关闭了</span>            <span class="hljs-keyword">if</span> (runStateAtLeast(c, SHUTDOWN))                <span class="hljs-keyword">continue</span> retry;            <span class="hljs-comment">// 如果线程池没关闭，那就是CAS失败了，说明期间线程数变动了，重新执行循环</span>        &#125;    &#125;    <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;    <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;    Worker w = <span class="hljs-keyword">null</span>;    <span class="hljs-keyword">try</span> &#123;        <span class="hljs-comment">// 将任务、线程封装到Worker对象中。Worker构造器中使用了我们配置的ThreadFactory来新建线程</span>        w = <span class="hljs-keyword">new</span> Worker(firstTask);        <span class="hljs-comment">// 获取上一行代码中Worker构造器里初始化的Thread对象</span>        <span class="hljs-keyword">final</span> Thread t = w.thread;        <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;            <span class="hljs-comment">// mainLock是线程池的主锁，当敏感操作时使用它</span>            <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;            mainLock.lock();            <span class="hljs-keyword">try</span> &#123;                <span class="hljs-keyword">int</span> c = ctl.get();                <span class="hljs-keyword">if</span> (isRunning(c) ||                    (runStateLessThan(c, STOP) &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;                    <span class="hljs-comment">// 文章上面说过线程的状态，这里判断线程是否为NEW状态。</span>                    <span class="hljs-keyword">if</span> (t.getState() != Thread.State.NEW)                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();                    <span class="hljs-comment">// 将worker加入队列</span>                    workers.add(w);                    workerAdded = <span class="hljs-keyword">true</span>;                    <span class="hljs-keyword">int</span> s = workers.size();                    <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)                        largestPoolSize = s;                &#125;            &#125; <span class="hljs-keyword">finally</span> &#123;                mainLock.unlock();            &#125;            <span class="hljs-keyword">if</span> (workerAdded) &#123;                t.start();                workerStarted = <span class="hljs-keyword">true</span>;            &#125;        &#125;    &#125; <span class="hljs-keyword">finally</span> &#123;        <span class="hljs-keyword">if</span> (! workerStarted)            addWorkerFailed(w);    &#125;    <span class="hljs-keyword">return</span> workerStarted;&#125;</code></pre><p>以上就是线程池中最重要的执行、添加线程的方法源码。源码有些生涩难懂，有些部分也有些超出常理，比如<code>for(;;)</code>这样的代码需要程序员对代码的可控性有非常精细的把握，不然就可能发生死循环。</p><p>还有一些方法比如<code>shutdown()</code>等，在这里就不一一展开了。它们相对于以上新增线程的代码复杂度稍微低一些，更容易看懂。</p><p><strong>另外，也建议读者看看线程池中内部类<code>Worker</code>的源码，源码比较简单易懂。它将线程、作业做了封装，在线程池中也是举足轻重的一部分。</strong></p><h2 id="总结">总结</h2><p>多线程一直是大型系统中最能提高性能，又最能增加bug的部分。要能合理、有效地使用多线程，线程池是绕不开的。其实线程池源码在仔细阅读后就会发现，线程池离我们也并不遥远。理解了线程池的原理、运行机制之后，相信对我们的多线程应用编写会有所帮助。</p><p>在使用线程池中，线程池参数的配置是十分重要的。合理地配置参数能让线程池发挥最大性能、吃最少资源。</p><p>最后，别忘了将线程池在生命周期结束时<code>shutdown()</code>，不然应用程序主线程结束了线程池仍会继续运行。</p><p>由于本人资历尚浅，才学有限，文章中难免有错误、纰漏、不严谨之处，还请大家不吝指教。希望文章能对读者有所帮助，共同进步。感谢阅读！</p><div class="note note-primary"><p>参考文献：</p><ul><li>《码出高效 Java开发手册》 —— 杨冠宝（孤尽） 高海彗（鸣莎）著</li><li><a href="https://github.com/alibaba/p3c/blob/master/Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C%EF%BC%88%E5%B5%A9%E5%B1%B1%E7%89%88%EF%BC%89.pdf" target="_blank" rel="noopener">《Java开发手册（嵩山版）》</a> —— alibaba在github开源内容</li></ul></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git子模块——在Git中再嵌套一个Git</title>
    <link href="/2020/05/13/git%E5%AD%90%E6%A8%A1%E5%9D%97/"/>
    <url>/2020/05/13/git%E5%AD%90%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<p>最近终于动手把博客好好地弄起来了！第一篇博文还是忍不住感叹一下～</p><p>第一篇文章，就从我部署博客遇到的问题说起。</p><h2 id="问题描述">问题描述</h2><div class="note note-primary"><p>友情提示：本文可能需要有一定的Git基础才能比较好理解。如果没接触过Git的同学推荐先学习Git的基础内容、熟练Git的基本使用。网上上手教程很多，如果想更进一步熟悉Git、了解Git的设计原理，更推荐<a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener">Git官方文档-Git Book</a></p></div><p>在搭建博客的过程中，我们往往为了美观会使用<ins>第三方主题</ins>。然后我遇到了这样一个问题：我想在我的Hexo博客中，<ins>尽可能方便地保持我的主题是最新的</ins>。</p><p>（我真的非常享受体会各种软件的各种新功能hahaha）</p><p>于是我就想在我已经构建Git的博客代码中，<code>git clone</code> 拿到主题的最新代码，并且可以更新。但是我的博客代码本身就已经有git版本管理，这就涉及到了Git子模块内容。</p><div class="note note-warning"><p>如果只是想拿一次主题代码（或者说子项目代码），而并不打算以后同步更新远程仓库的话，是无需使用Git子模块的。这种情景简单的办法有：拉到主题（子项目代码）后删除子项目目录中的.git文件夹（及.gitignore等git相关文件）即可。请结合好自己的需求。</p></div><div class="note note-info"><p>为了方便说明，我后面用<code>父项目</code>代表<code>博客</code>，<code>子项目</code>代表博客里的<code>主题</code></p></div><h3 id="直接克隆会遇到的问题">直接克隆会遇到的问题</h3><p>首先，如果我们在一个Git项目中直接再<code>git clone</code>一个项目看看会有什么效果：</p><pre><code class="hljs bash"><span class="hljs-comment"># 先创建一个父项目，初始化Git</span>$ <span class="hljs-built_in">cd</span> parent$ git init已初始化空的 Git 仓库于 /path/to/parent<span class="hljs-comment"># 放一个测试用的文件id，存入1</span>$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'1'</span> &gt; id<span class="hljs-comment"># 远程拉一个子项目代码</span>$ git <span class="hljs-built_in">clone</span> https://github.com/your/SubProject sub$ git status位于分支 master尚无提交未跟踪的文件:  （使用 <span class="hljs-string">"git add &lt;文件&gt;..."</span> 以包含要提交的内容）        id        sub/提交为空，但是存在尚未跟踪的文件（使用 <span class="hljs-string">"git add"</span> 建立跟踪）<span class="hljs-comment"># 修改子项目内容</span>$ <span class="hljs-built_in">cd</span> son$ <span class="hljs-built_in">echo</span> <span class="hljs-string">'sub'</span> &gt; name<span class="hljs-comment"># 我们添加文件到git就会报提示，大致内容就是：“你在本库（父项目）中添加了其他库（子项目），</span><span class="hljs-comment"># 如果你在其他地方clone父项目，将不会包含子项目的内容。你可能要用到git submodule。”</span>$ git all --all<span class="hljs-comment"># 提示：You've added another git repository inside your current repository.</span><span class="hljs-comment"># 提示：Clones of the outer repository will not contain the contents of</span><span class="hljs-comment"># 提示：the embedded repository and will not know how to obtain it.</span><span class="hljs-comment"># 提示：If you meant to add a submodule, use:</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：  git submodule add &lt;url&gt; son</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：If you added this path by mistake, you can remove it from the</span><span class="hljs-comment"># 提示：index with:</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：  git rm --cached son</span><span class="hljs-comment"># 提示：</span><span class="hljs-comment"># 提示：See "git help submodule" for more information.</span><span class="hljs-comment"># 这时我们可以看到son/name并没有被添加到git，只有个son文件夹</span>$ git status位于分支 master尚无提交要提交的变更：  （使用 <span class="hljs-string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）        新文件：   id        新文件：   sub</code></pre><p>经过实践，我们发现直接在父项目中<code>git clone</code>子项目是无法被父项目的Git库感知和捕捉的，换言之就是父项目的Git无法添加子项目的代码。这样的后果就是当别处要<code>git clone</code>你的项目时（或着你的项目要提交到远程仓库时），<ins>别人拿不到项目中的子项目代码</ins>。</p><p>因此我们根据上面Git给的提示，学习学习<code>Git子模块</code>。</p><h2 id="Git子模块">Git子模块</h2><div class="note note-primary"><p>主要参考自<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a></p></div><div class="note note-light"><p>子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。——Git官网</p></div><h3 id="添加Git子模块">添加Git子模块</h3><p>我们首先将一个已存在的 Git 仓库添加为正在工作的仓库的子模块。使用<code>git submodule add</code>命令。</p><pre><code class="hljs bash">$ git submodule add https://github.com/your/SubProject sub</code></pre><p>此时会生成一个<code>.gitmodules</code>文件，保存了项目 URL 与已经拉取的本地目录之间的映射：</p><pre><code class="hljs conf">[submodule &quot;sub&quot;]  path &#x3D; sub  url &#x3D; https:&#x2F;&#x2F;github.com&#x2F;your&#x2F;SubProject</code></pre><div class="note note-warning"><p>如果有多个子模块，该文件中就会有多条记录。 <ins>要重点注意的是，该文件也像 .gitignore 文件一样受到（通过）版本控制。 它会和该项目的其他部分一同被拉取推送。</ins> 这就是克隆该项目的人知道去哪获得子模块的原因。</p></div><p>输入<code>git submodule status</code>命令即可以查看子模块的状态</p><div class="note note-warning"><p>需要注意的是<code>git submodule add</code>会自动将远程的代码拉到本地。此时你会发现你添加完子模块，子模块的代码已经拉到本地了。</p><p>但如果<code>git clone</code>父项目是不会拉到子项目的内容的。原因是父模块的Git只保存了子模块的版本信息，而并没有保存子模块的代码内容。<code>git clone</code>父模块后需要<code>git submodule init</code>和<code>git submodule update</code>才能根据子模块的版本信息拉取对应的子模块内容。这块后续会说到。</p></div><p>此时我们的子模块就添加完成了。</p><h3 id="提交父项目至远程库">提交父项目至远程库</h3><p>假设我们只是拿子项目的内容使用，暂时不更改子项目内容。此时我们像平时一样地提交父项目内容：</p><pre><code class="hljs bash">$ git add --all$ git commmit -am <span class="hljs-string">'添加子项目'</span>[master fb9093c] 添加子项目 2 files changed, 4 insertions(+) create mode 100644 .gitmodules create mode 160000 sub</code></pre><div class="note note-warning"><p>注意<code>sub</code>记录的<code>160000</code>模式。这是 Git 中的一种特殊模式，它本质上意味着你是将一次提交记作一项目录记录的，<ins>而非将它记录成一个子目录或者一个文件。</ins>（这也是为什么<code>git clone</code>父项目的代码无法直接拿到子项目内容的原因！）</p></div><pre><code class="hljs bash">$ git push origin master</code></pre><h3 id="克隆含有子模块的项目">克隆含有子模块的项目</h3><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> https://github.com/your/MainProject$ <span class="hljs-built_in">cd</span> MainProject<span class="hljs-comment">#此时克隆父项目完毕，sub为子项目文件夹</span>$ ls -a.git .gitmodule id sub<span class="hljs-comment"># 进入子项目文件夹会发现没有子项目内容，是空的</span>$ <span class="hljs-built_in">cd</span> sub$ ls</code></pre><div class="note note-info"><p>你必须运行两个命令：<code>git submodule init</code>用来初始化本地配置文件，而<code>git submodule update</code>则从该项目中抓取所有数据并检出父项目中列出的合适的提交。</p></div><pre><code class="hljs bash">$ git submodule initSubmodule <span class="hljs-string">'sub'</span> (https://github.com/your/SubProject) registered <span class="hljs-keyword">for</span> path <span class="hljs-string">'sub'</span>$ git submodule update</code></pre><p>现在<code>sub</code>子目录是处在和之前提交时相同的状态了。</p><p>不过还有更简单一点的方式。 如果给<code>git clone</code>命令传递<code>--recurse-submodules</code>选项，它就会自动初始化并更新仓库中的每一个子模块， 包括可能存在的嵌套子模块。</p><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> --recurse-submodules https://github.com/your/MainProjectCloning...</code></pre><p>如果你已经克隆了项目但忘记了<code>--recurse-submodules</code>，那么可以运行<code>git submodule update --init</code> 将<code>git submodule init</code>和<code>git submodule update</code>合并成一步。如果还要初始化、抓取并检出任何嵌套的子模块， 请使用简明的<code>git submodule update --init --recursive</code>。</p><h3 id="Git子模块的使用">Git子模块的使用</h3><p>在Git子模块目录中，你可以像往常一样使用<code>git fetch</code>,<code>git merge</code>,<code>git diff</code>（在父目录使用<code>git diff --submodule</code>）等功能。就跟普通的Git模块使用起来差不多，这里就不多介绍了。在父目录可以用<code>git submodule update --remote</code>来更新子模块，此命令默认会假定你想要更新并检出子模块仓库的<code>master</code>分支。</p><h3 id="发布子模块改动">发布子模块改动</h3><p>现在我们的子模块目录中有一些改动。 其中有一些是我们通过更新从上游引入的，而另一些是本地生成的，由于我们还没有推送它们，所以对任何其他人都不可用。</p><p>可以在子模块使用<code>git diff</code>命令查看改动。</p><p>如果我们在主项目中提交并推送但并不推送子模块上的改动，其他尝试检出我们修改的人会遇到麻烦， 因为他们无法得到依赖的子模块改动。那些改动只存在于我们本地的拷贝中。</p><p>为了确保这不会发生，你可以让 Git 在推送到主项目前检查所有子模块是否已推送。<code>git push</code>命令接受可以设置为 “check” 或 “on-demand” 的<code>--recurse-submodules</code>参数。 如果任何提交的子模块改动没有推送那么 “check” 选项会直接使<code>push</code>操作失败。</p><pre><code class="hljs bash">$ git push --recurse-submodules=checkThe following submodule paths contain changes that cannot be found on any remote:  subPlease try  git push --recurse-submodules=on-demandor <span class="hljs-built_in">cd</span> to the path and use  git pushto push them to a remote.</code></pre><p>也就是说<code>--recurse-submodules=check</code>的时候，子项目没有提交是会不允许父项目提交的。如果把&quot;check&quot;改成&quot;on-demand&quot;，那Git会在提交父项目前先提交子项目。</p><pre><code class="hljs bash">$ git push --recurse-submodules=on-demandPushing submodule <span class="hljs-string">'sub'</span>Counting objects: 9, <span class="hljs-keyword">done</span>.Delta compression using up to 8 threads.Compressing objects: 100% (8/8), <span class="hljs-keyword">done</span>.Writing objects: 100% (9/9), 917 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.Total 9 (delta 3), reused 0 (delta 0)To https://github.com/your/SubProject   c75e92a..82d2ad3  stable -&gt; stableCounting objects: 2, <span class="hljs-keyword">done</span>.Delta compression using up to 8 threads.Compressing objects: 100% (2/2), <span class="hljs-keyword">done</span>.Writing objects: 100% (2/2), 266 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.Total 2 (delta 1), reused 0 (delta 0)To https://github.com/your/MainProject   3d6d338..9a377d1  master -&gt; master</code></pre><div class="note note-warning"><p>如果不推送子模块就只推送父模块，那子模块的内容别人可能会获取不到。因为父模块保存的子模块的版本只在你本地存在。</p></div><h2 id="结语">结语</h2><p>以上就是子模块的一些基础概念跟内容了。这个设计也很好地解决了我的需求，Git真的是非常强大的工具。</p><p>本文介绍子模块相关的内容有限，想要更多更详细的内容推荐<a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a>。</p><div class="note note-primary"><p>参考文献：</p><ul><li><a href="https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E5%AD%90%E6%A8%A1%E5%9D%97" target="_blank" rel="noopener">Git官网-Git子模块章节</a></li></ul></div>]]></content>
    
    
    <categories>
      
      <category>技术</category>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
